<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>访问者</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining the different Accessors" />
  <meta name="rh-index-keywords" content="Accessors" />
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>访问者</h1>
  <p><span class="notranslate">GameMaker Language</span> (<span class="notranslate">GML</span>)也允许你通过使用称为<b>访问器</b>的逻辑表达式来访问某些<a href="../GML_Reference/Data_Structures/Data_Structures.htm">数据结构</a>和<a href="Arrays.htm">数组</a>。这与你通常使用数组时的结构相似，只是我们在第一个参数前使用了一个<em>标识符</em>，以告诉<span data-keyref="GameMaker Name">GameMaker</span>你正在处理一个（先前创建的）数据结构或数组字面。</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">DS列表 [|]</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">DS列表</a>的语法是：。</p>
    <p class="code">list_index[| index]</p>
    <p class="dropspot">因此，当你使用<span class="inline">ds_list_create()</span> 来创建你的列表时，你将使用列表索引（你已经存储在一个变量中）来引用它，&quot;索引 &quot;值是列表中要设置或添加的位置。例如，下面的代码创建了一个列表，然后添加了10个条目，将每个条目设置为0到9的随机数。</p>
    <p class="code">ds = ds_list_create();<br />
      var index = 0;<br />
      repeat(10)<br />
      {<br />
          ds[| index++] = irandom(9);<br />
      }</p>
    <p class="dropspot">注意，如果你使用表达式向已经有一个值的索引添加引用，先前的值将被替换，而不是向列表中添加更多的索引。要增加更多的条目，你需要知道ds_list的大小，并把它们加到最后。同样值得注意的是，你可以设置一个<i>大于</i>被引用列表大小的列表索引，这将设置该值，同时扩展列表，并将列表中直到给定索引的所有位置初始化为0。</p>
    <p class="dropspot">一旦你创建了你的列表结构并将数据填入其中，要想从列表中获取数值，你需要做一些事情。</p>
    <p class="code">value = ds[| 5];</p>
    <p class="dropspot">以上将从位置5（第六个索引，因为列表从0开始）获得数值，并将其存储在一个变量中。如果你提供的位置在列表大小之外，那么将返回值 <span class="inline">undefined</span> ，你可以用函数检查一下 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">DS地图[?］</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS地图</a>的语法是：。</p>
    <p class="code">map_index[? key]</p>
    <p class="dropspot">在用<span class="inline">ds_map_create()</span> 创建你的地图后，你将使用你存储在一个变量中的地图索引来引用它，&quot;key &quot;值是要设置或获取的地图键。例如，下面的代码创建了一个地图，然后用这个语法向它添加了一些条目。</p>
    <p class="code">ds = ds_map_create();<br />
      ds[? &quot;Name&quot;] = &quot;Hamish&quot;;<br />
      ds[? &quot;Company&quot;] = &quot;MacSeweeny Games&quot;;<br />
      ds[? &quot;Game&quot;] = &quot;Catch The Haggis&quot;;</p>
    <p class="dropspot">请注意，如果地图已经包含了与你要添加的相同的键值，它不会用新的值创建一个重复的键，而是会替换之前的值。</p>
    <p class="dropspot">一旦你创建了你的地图结构并将数据填入其中，要从一个特定的地图键中获取数值，你会有这样的想法。</p>
    <p class="code">value = ds[? &quot;Name&quot;];</p>
    <p class="dropspot">以上将从键 &quot;Name &quot;中获取数值并将其存储在一个变量中，但要注意，如果给定的键在DS地图中不存在，那么返回的数值将是 <span class="inline">undefined</span> 。这可以用函数来检查 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">DS网格[#]</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">DS网格</a>的语法是：。</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot">在用<span class="inline">ds_grid_create()</span> 函数创建了你的网格后，你将使用你存储在一个变量中的网格索引来引用它，&quot;xpos &quot;和 &quot;ypos &quot;是在网格中获得或设置一个值的位置。例如，下面的代码创建了一个网格，将其清除为0，然后再向其添加一些条目。</p>
    <p class="code">ds = ds_grid_create();<br />
      ds_grid_clear(ds, 0);<br />
      var gw = ds_grid_width(ds) - 1;<br />
      var gh = ds_grid_height(ds) - 1;<br />
      repeat(10)<br />
      {<br />
          var xx = irandom(gw);<br />
          var yy = irandom(gh);<br />
          if (ds[# xx, yy] == 0)<br />
          {<br />
              ds[# xx, yy] = 1;<br />
          }<br />
      }</p>
    <p class="dropspot">一旦你创建了你的网格结构并填满了数据，要想从一个特定的网格位置获得数值，你就得这样做。</p>
    <p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p>
    <p class="dropspot">以上将根据鼠标的位置从给定的ds_grid中获取数值（除以<span class="notranslate">room</span> 中的 &quot;单元格 &quot;宽度以获得正确的位置）。如果你提供的位置在网格边界之外，那么将返回值 <span class="inline">undefined</span> ，你可以用函数检查这个值 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">数组 [@]</a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">这个访问器只有在启用<a href="../../Settings/Game_Options.htm">写时复制选项</a>时才会使用。</p>
    <p class="dropspot">数组也有自己的访问器，其工作方式与上面列出的数据结构的访问器类似。然而，数组访问器有一个有趣的特性，那就是允许你从一个<a href="Script_Functions.htm">脚本函数</a>或 <a href="Method_Variables.htm"><span class="notranslate">method</span></a>而不需要复制它。当你把一个数组传入一个函数时，它是<strong>通过引用来传递的</strong>，这意味着数组本身并没有被送入<span class="notranslate">script</span> ，而只是被引用来获取数据。通常情况下，如果你需要改变数组，它将被<em>复制到 </em> <span class="notranslate">script</span> ，然后你需要传回（返回）复制的数组以更新原始数组。这可能会产生昂贵的处理开销，所以你可以使用访问器来代替，因为这将<em>直接 </em>改变原始数组，而不需要复制它。你可以在下面的例子中看到这是如何工作的。</p>
    <p class="dropspot">数组的语法，使用 <span class="inline">@</span> 访问器，是。</p>
    <p class="code">array[@ i]</p>
    <p class="dropspot">当你在一个实例中创建了你的数组后，你可以通过引用把它传递给一个<span class="notranslate">script</span> ，并使用访问器<span class="inline">@</span> ，直接改变它。例如，你可以创建数组并这样调用函数。</p>
    <p class="code">array[99] = 0;<br />
      array_populate(array);</p>
    <p class="dropspot">该函数本身会有这样的内容。</p>
    <p class="code">function array_populate(_array)<br />
      {<br />
          var a = _array; var i = 0; repeat(25)<br />
          {<br />
              i = irandom(99);<br />
              while (a[i] != 0)<br />
              {<br />
                  i = irandom(99);<br />
              }<br />
              a[@ i] = 100;<br />
          }<br />
      }</p>
    <p class="dropspot">这个函数所做的就是在数组中随机选择25个位置，并将所选数组位置的值设置为100。</p>
    <p class="dropspot">当然，<strong>当写时复制</strong>被禁用时， <span class="inline">@</span> 访问器是不需要的。</p>
    <p class="note"><span class="note">注意</span>在脚本函数中处理<span class="inline">argument[n]</span> 数组时不能使用数组访问器 <span class="inline">@</span> 。</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">结构 [$ ]</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span><a href="Structs.htm">结构体</a>的语法是</span></p>
    <p class="code">struct[$ &quot;name&quot;]</p>
    <p class="dropspot">这个访问器本质上是对函数<span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> 和<a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a></span>的封装<span>，你可以像使用DS地图的访问器那样使用它。例如，如果你创建了一个<span class="notranslate">struct</span> ，并想从一个叫做 &quot;my_health &quot;的变量中获取一个值，那么你可以这样做。</span></p>
    <p class="code">var _hp = struct[$ &quot;my_health&quot;];</p>
    <p class="dropspot">正如你所看到的，你没有提供变量本身，而是提供了一个带有该变量的<em>字符串</em>。请注意，如果<span class="notranslate">struct</span> ，没有一个给定名称的变量，那么访问器将返回 <span class="inline">undefined</span> 作为值。</p>
    <p class="dropspot">要在<span class="notranslate">struct</span> 中设置一个变量，那么你应该做以下工作</p>
    <p class="code">struct[$ &quot;my_score&quot;] = 100;</p>
    <p class="dropspot">与获得一个值一样，你提供要设置的变量的名称作为<span class="notranslate">string</span> ，它将被设置为给定的值。如果使用的变量名称在<span class="notranslate">struct</span> ，那么它将被创建并设置为给定的值。</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>访问器的一个重要特征是它们可以被<i>链</i>在一起。这意味着如果你有几个嵌套的数据结构和/或数组，就不再需要使用各种函数来访问嵌套结构深处的一个值了。例如，假设你有一个数组，而数组中的每一项都是一个DS列表，像这样。</p>
  <p class="code">array = array_create(3);<br />
    for (var i = 0; i &lt; 3; ++i;)<br />
    {<br />
        array[i] = ds_list_create();<br />
        switch(i)<br />
        {<br />
            case 0:<br />
                with (obj_Wall) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 1:<br />
                with (obj_Door) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 2:<br />
                with (obj_Chest) ds_list_add(array[i], id);<br />
            break;<br />
        }<br />
    }
  </p>
  <p>在上面的代码中，我们已经创建了一个3项数组，并为每个数组分配了一个DS列表，然后我们用游戏中各种<span class="notranslate">objects</span> 的实例ID填充了不同的列表。现在，要访问其中一个列表中的ID，我们可以做以下工作。</p>
  <p class="code">var _list = array[0];<br />
    var _id = ds_list_find_value(_list, 0);</p>
  <p>然而，你可以使用链式访问器来做同样的事情，这种方式更简洁，使用的代码更少。</p>
  <p class="code">var _id = array[0][| 0];</p>
  <p>你可以用这种方式把多个访问器连锁起来，它们可以是多种类型的，以获得存储在嵌套结构各部分的信息。下面是一些更多的例子。</p>
  <p class="code">// Access a grid that has been added to a list that is part of a map:<br />
    var _a = data[? &quot;lists&quot;][| 0][# 0, 0];<br />
    <br />
    // Access an array nested in a list from a script and modify it:<br />
    data[| 0][@ 10] = 100;<br />
    <br />
    // Access a map nested in a grid nested in a list nested in an array:<br />
    data[0][| 10][# 3, 4][? &quot;key&quot;] = &quot;hello world&quot;;
  </p>
  <p>对事物使用链式访问器不仅意味着你可以写出更紧凑的代码，它还允许你使用迭代（例如，使用一个 <a href="Language_Features/for.htm"><span class="inline">for</span></a>循环）和其他技术，以更干净、更直观的方式访问你的数据。</p>
  <p>值得注意的是，当以这种方式使用访问器时，你应该总是为数组使用 <span class="inline">@</span> 访问器，否则你将为正在执行的任何操作增加额外的开销。如上所述，默认情况下，数组是通过引用传递到函数中，然后在修改时使用 &quot;写时复制 &quot;行为。然而，如果数组是一个链的一部分，那么链中的前一个项目将用复制的数组进行更新，而 &quot;原始 &quot;将被删除。比如说，做这样的事情。</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][0] = 200;
  </p>
  <p>实现的结果与这样做的结果相同。</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][@ 0] = 200;
  </p>
  <p>然而，第二个例子更好，因为它没有先复制整个数组的不必要的开销。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">返回。<a href="GML_Overview.htm">GML概述</a></div>
        <div style="float:right">下一步。<a data-xref="{title}" href="Language_Features.htm">语言特点</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->
</body>
</html>
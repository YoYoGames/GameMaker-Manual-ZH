<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>数组</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining Arrays" />
  <meta name="rh-index-keywords" content="Arrays" />
  <meta name="search-keywords" content="Arrays" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>数组</h1>
  <p>数组可以非常有用，是制作游戏的一个重要部分。它本质上是一种变量类型，可以作为 &quot;列表 &quot;容纳多个值--考虑以下代码。</p>
  <p class="code">numbers = [ 0, 1, 2, 3, 4, 5 ];<br />
    <br />
    fruits = [ &quot;Apples&quot;, &quot;Oranges&quot;, &quot;Mangoes&quot; ];
  </p>
  <p>使用<span class="inline2">[item, item, item]</span>语法，我们正在创建一个数组，并将其存储在一个变量中。存储在数组中的项目以后可以通过该变量访问，使用一个整数，从 <span class="inline">0</span> ，放在<span class="inline2">[]</span>括号内。</p>
  <p class="code">first_fruit = fruits[ 0 ];<br />
    second_fruit = fruits[ 1 ];<br />
    // ...and so on.</p>
  <p><label for="aone">一个基本的数组被归类为有一个<strong>维度</strong>，但是你也可以有超过一个维度的数组。下面的章节将解释这两种类型的数组。</label></p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">一维数组</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">在进一步讨论之前，让我们澄清一下数组究竟是什么，以及它是如何结构的。数组只是一种分配给变量的<a href="Data_Types.htm">数据类型</a>，它不仅可以包含一个值，而且可以包含多个值。下面的图片显示了一个基本数组的示意图。</p>
    <p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png" /></p>
    <p class="dropspot">这被称为<strong>1D</strong>（一维）数组，正如你所看到的，该数组存储在变量&quot;<span class="inline">a</span>&quot;中，包含多个值。要访问这个数组，你需要做如下的事情。</p>
    <p class="code">var _val = a[0];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">上面的代码从数组 &quot;<span class="inline">a</span>&quot; 的第0个位置获取数值，然后将其输出到控制台，根据上图所示数组的内容，它将输出125。如果你做了以下事情。</p>
    <p class="code">var _val = a[3];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">输出将显示 &quot;嗨！&quot;。</p>
    <p class="dropspot">正如你所看到的，你给数组一个变量名称，然后在方括号中给一个值 <span class="inline">[]</span> ，其中值是在数组中获取数据的位置。因此，从本质上讲，数组是一个有若干槽位的容器，用来存储数值，容器中的每个位置都有一个特定的数字来标识，这就是我们在 <span class="inline">[]</span> 。值得注意的是，数组的内容<b>总是从0开始</b>，而且<i>永远不会是负数</i></p>
    <h3 class="dropspot">       创建数组</h3>
    <p class="dropspot">我们已经展示了如何检查一个数组的数据，但我们如何创建数组来开始呢？首先，在我们使用它之前，它必须被<i>初始化</i>，否则<span data-keyref="GameMaker Name">GameMaker</span>会给我们一个错误。初始化数组意味着我们给数组的每个槽一个初始值，为它在项目代码的其他地方使用做准备。记住这一点很重要，因为这意味着你在使用数组之前必须做一定的计划，但使用像这样的重复<span class="notranslate">loop</span> 来初始化一个数组也很容易。</p>
    <p class="code">var i = 9;<br /><br />
      repeat(10)<br />
      {<br />
          array[i] = 0;<br />
          i -= 1;<br />
      }</p>
    <p class="dropspot">这段简单的代码将初始化一个10个槽的数组（从0到9），以保持0，即：数组中的每个槽都包含值0。你会注意到，这个数组是<i>倒着</i>初始化的，最后一个值被首先定义。这不是严格意义上的需要，但却是最佳的方式，因为它将在内存中保留一个与数组精确大小相同的空间，而如果你从0<em>向上</em>初始化一个数组，每增加一个值就必须重新分配内存（所以对于一个10槽的数组，在<span class="notranslate">loop</span> 中初始化它将改变10次内存分配）。对于较小的数组来说，速度上的差异可以忽略不计，但是较大的数组应该尽可能地用这种方式来优化。</p>
    <p class="note"><b>注意</b>：HTML5导出是上述规则的例外，当针对该规则时，你应该按照从0向上的连续顺序初始化数组。</p>
    <p class="dropspot">你还可以使用<span class="notranslate">GML</span> 函数 <a href="../GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a>来初始化一个有固定大小的数组，你甚至可以创建<em>没有任何</em>值的 &quot;空 &quot;数组，例如。</p>
    <p class="code">my_array = [];</p>
    <p class="dropspot">这告诉<span class="notranslate">GameMaker</span> ，变量&quot;<span class="inline">my_array</span>&quot;是一个数组，然后你可以在未来的任何时候向它<a href="../GML_Reference/Variable_Functions/array_push.htm">添加值</a>。然而，如果你试图访问一个空数组中的一个值，那么你将得到一个错误。<br /></p>
    <p class="dropspot">如果你已经知道你想把哪些项目放入数组，你可以在声明数组时在括号中加入逗号分隔的值。</p>
    <p class="code">my_array = [&quot;Steve&quot;, 36, &quot;ST-3V3 - Steve Street&quot;];</p>
    <h3 class="dropspot">       阵列的界限</h3>
    <p class="dropspot">你应该始终注意只访问有效的数组位置，因为试图访问一个数组之外的值也会出现错误。例如，这将导致项目在运行时崩溃。</p>
    <p class="code">my_array = array_create(5, 0);<br />
      var _val = my_array[6];</p>
    <p class="dropspot">数组初始化时只有5个位置，但我们已经试图得到第7个位置--因为数组是从0开始编号的， <span class="inline">array[6]</span> 是第7个位置--因此游戏产生了错误并崩溃了。</p>
    <h3 class="dropspot">       使用数组</h3>
    <p class="dropspot">现在我们如何实际地使用数组呢？就像我们使用一个普通的变量一样，如下面的例子所示。</p>
    <p class="code">// Add two array values together<br />
      total = array[0] + array[5];<br />
      <br />
      // Check an array value<br />
      if array[9] == 10<br />
      {<br />
          // Do something<br />
      }<br />
      <br />
      // Draw an array value<br />
      draw_text(32, 32, array[3]);
    </p>
    <p class="dropspot">由于数组是按顺序编号的，这意味着你也可以通过<span class="notranslate">loop</span> ，执行额外的动作，就像我们初始化它一样。</p>
    <p class="code">var total = 0;<br />
      <br />
      for (var i = 0; i &lt; 10; ++i)<br />
      {<br />
          total += array[i];<br />
          draw_text(32, 32 + (i * 32), array[i]);<br />
      }<br />
      <br />
      draw_text(32, 32 + (i * 32), total);
    </p>
    <p class="dropspot">上面的代码将把我们数组中的所有数值加起来，逐一画出，然后在最后画出总数值。</p>
    <h3 class="dropspot">       删除数组</h3>
    <p class="dropspot">关于数组，最后要提到的是，你可以删除一个数组，只需将定义该数组的变量 &quot;重新赋值 &quot;为一个单一的值。这将释放出与该数组的所有位置和数值相关的内存。比如说。</p>
    <p class="code">// Create an array<br />for (var i = 9; i &gt; -1; --i)<br />
      {<br />
          a[i] = i;<br />
      }<br />
      <br />
      // Delete the array<br />
      a = -1;
    </p>
    <p class="dropspot">如果数组有多个维度（见下文），它们也将全部被清理，注意，当你在实例中创建数组时，当实例从游戏中删除时，这些数组不需要被清理，因为它们将在Destroy或<span class="notranslate">Room</span> End时被<a class="glossterm" data-glossterm="垃圾收集器" href="#">垃圾收集器</a>自动删除。然而，如果数组中的任何位置持有对<em>动态</em>资产的引用，如粒子系统、<span class="notranslate">buffers</span> 、或数据结构，那么在数组被删除、实例被销毁或<span class="notranslate">room</span> 结束之前，这些<em>将</em>需要被销毁。</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">多维数组</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><span style="text-align: justify;">我们现在知道什么是一维数组，但在<span data-keyref="GameMaker Name">GameMaker</span>中，你可以有多维数组，其结构基本上是数组中的数组中的数组......例如，下面是一个<strong>2D</strong>（二维）数组。</span></p>
    <p class="code">array[0][0] = 5;</p>
    <p class="dropspot">这实质上是告诉<span class="notranslate">GameMaker</span> ，这个数组实际上是由各种一维数组组成的。下面是一个扩展的例子。</p>
    <p class="code">array<strong>[0]</strong>[0] = 0;<br />
      array<strong>[0]</strong>[1] = 1;<br />
      array<strong>[0]</strong>[2] = 2;<br />
      <br />
      array<strong>[1]</strong>[0] = 3;<br />
      array<strong>[1]</strong>[1] = 4;<br />
      <strong></strong>array<strong>[1]</strong>[2] = 5;
    </p>
    <p class="dropspot">在上面的代码中， <span class="inline">array[0]</span> 持有另一个数组，<span class="inline">array[1]</span> 也是如此。</p>
    <p class="dropspot">多维数组在使用前需要进行初始化，与单一的一维数组相同，并且可以保存实数、<span class="notranslate">strings</span> ，以及其他任何<a href="Data_Types.htm">数据类型</a>，就像任何变量一样，这使得它们成为任何需要以容易访问的方式存储大量数据的游戏的理想候选者（记住，你可以轻松地通过数组<span class="notranslate">loop</span> ）。</p>
    <p class="dropspot">你也可以通过嵌套一维数组在一条语句中初始化一个多维数组。</p>
    <p class="code">two_dimensional_array = <br />
      [<br />
          [&quot;Apple&quot;, 10, 2],<br />
          [&quot;Orange&quot;, 5, 2],<br />
          [&quot;Mango&quot;, 15, 4],<br />
          // ...and so on.<br />
      ]</p>
    <p class="dropspot">多维数组也不仅仅<em>局限于 </em>两个维度，你可以根据你的代码的需要给数组增加3、4或更多的维度，只需进一步添加 <span class="inline">[n]</span> ，例如。</p>
    <p class="code">array[0][0][0] = 1;     // A three dimensional array<br />
      array[0][0][0][0] = 1;  // A four dimensional array<br />
      // etc...</p>
    <p class="dropspot">还应该注意的是，数组中每个维度的长度可以不同，所以你可以让数组初始维度的长度为3，但第二个维度条目可以是第一个维度中每个槽的不同长度；例如。</p>
    <p class="code">array[2][2] = &quot;3&quot;;<br />
      array[2][1] = &quot;2&quot;;<br />
      array[2][0] = &quot;1&quot;;<br />
      <br />
      array[1][3] = &quot;four&quot;;<br />
      array[1][2] = &quot;three&quot;;<br />
      array[1][1] = &quot;two&quot;;<br />
      array[1][0] = &quot;one&quot;;<br />
      <br />
      array[0][1] = 2;<br />
      array[0][0] = 1;
    </p>
    <p class="dropspot">在上述代码中， <span class="inline">array[0]</span> 有2个槽， <span class="inline">array[1]</span> 有4个槽， <span class="inline">array[2]</span> 有3个槽。</p>
    <h3 class="dropspot">       扩展实例</h3>
    <p class="dropspot">这里有一个关于如何在实际游戏中使用它的最后一个例子。假设你想根据一个随机值在游戏中的四个不同点上产生四个不同的敌人。那么，我们可以用一个2维的数组来做这件事，并且省去了编写大量的代码。</p>
    <p class="dropspot">首先，我们应该初始化我们将在 &quot;控制器 &quot;<span class="notranslate">object</span> 的Create事件中使用的数组（注意使用注释来提醒你每个数组条目的作用）。</p>
    <p class="code">enemy[3][2] = 448;       //y position<br />
      enemy[3][1] = 32;        //x position<br />
      enemy[3][0] = obj_Slime; //Object<br />
      enemy[2][2] = 448;<br />
      enemy[2][1] = 608;<br />
      enemy[2][0] = obj_Skeleton;<br />
      enemy[1][2] = 32;<br />
      enemy[1][1] = 608;<br />
      enemy[1][0] = obj_Knight;<br />
      enemy[0][2] = 32;<br />
      enemy[0][1] = 32;<br />
      enemy[0][0] = obj_Ogre;</p>
    <p class="dropspot">我们现在有了<span class="notranslate">objects</span> 来生成实例，以及它们在<span class="notranslate">room</span> 中相应的x和y的生成坐标，都存储在我们的数组中。现在可以在控制器的另一个事件中使用<span class="notranslate">object</span> （例如一个警报，或一个按键事件），如下所示。</p>
    <p class="code">//get a random number from 0 to 3, inclusive<br />
      var i = irandom(3);<br />
      <br />
      //Use the array to create the object<br />
      instance_create_layer(enemy[i][1], enemy[i][2], &quot;Enemy_Layer&quot;, enemy[i][0]);
    </p>
    <p class="dropspot">这段简短的代码现在将在游戏中生成一个随机的敌人<span class="notranslate">room</span> ，它使用的代码远远少于 &quot;<span class="inline">if / then / else</span>&quot;结构或甚至 &quot;<span class="inline">switch</span>&quot;，而且由于数组是在创建事件中一起初始化的，所以编辑和改变这些值要容易得多，因为它们不是<a class="glossterm" data-glossterm="硬编码" href="#">硬编码</a>到项目代码的其他部分。</p>
  </div>
  <p> </p>
  <h2>作为函数参数的数组</h2>
  <p>你可以将数组作为参数传入<a href="Script_Functions.htm">脚本函数</a>和<a href="Method_Variables.htm">方法变量</a>中，并在函数的任何地方修改这些数组。这样做也会修改原来的数组。</p>
  <p>例如，这个函数只是改变了传入数组的前三个元素。</p>
  <p class="code">modify_array = function (array)<br />
    {<br />
        array[0] = 2;<br />
        array[1] = 4;<br />
        array[2] = 6;<br />
    }</p>
  <p>现在你可以创建一个数组并将其传入该函数，该函数将修改数组。</p>
  <p class="code">my_array = [100, 4, 214];<br />
    <br />
    modify_array(my_array);<br />
    <br />
    show_debug_message(my_array); // Prints [2, 4, 6];
  </p>
  <p>在以前的<span class="notranslate">GameMaker</span> 版本中，情况并非如此，因为在一个函数中修改一个数组会创建一个副本。如果需要的话，这种<em>过时的</em>行为仍然可以启用：请阅读下面的<strong>&quot;写时复制</strong>&quot;部分以了解更多信息。</p>
  <h2 id="h">写作中的复制</h2>
  <p>写入时复制行为已被弃用，只有在<a href="../../Settings/Game_Options.htm">常规游戏选项</a>中启用<strong>&quot;为数组启用写入时复制行为</strong>&quot;时才会被使用。本节描述了启用该选项时数组的行为。</p>
  <p>正如上一节所述，数组可以作为参数传入函数。要做到这一点，你只需要指定数组变量（不需要每个单独的位置，也不需要 <span class="inline">[]</span> 括号），整个数组将<b>以引用的方式传递</b>到函数中。</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    do_something(my_array);
  </p>
  <p>然而，<strong>当写时复制</strong>被启用时，在函数中改变数组的任何值会创建一个带有你的修改的临时副本。原始数组不会被修改。这种行为被称为写时复制。</p>
  <p>要实际修改传入函数的原始数组，你必须把它返回，或者使用 <span class="inline">@</span> 访问器。</p>
  <p>例如，上面调用的函数<span class="inline2">do_something()</span>，可能会做一些简单的事情，比如说。</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    }</p>
  <p>现在你会期望<span class="inline2">my_array</span>持有<span class="inline2">1、200、4</span>等值，这通常是正确的--但是<strong>当写时复制</strong>被启用时，原始数组仍然不受影响。</p>
  <p>为了解决这个问题，你可以让函数<strong>返回</strong>修改后的数组副本，然后再把它应用到原始变量上。</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    my_array = do_something(my_array);
  </p>
  <p>该函数本身将返回修改后的数组。</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    <br />
        return array;<br />
    }
  </p>
  <p class="note"><span class="note">注意</span><b> </b>如果你不改变数组的任何值，而是引用它们，那么上面的代码就没有必要。引用一个数组不会复制它，而且解析起来会更快。</p>
  <p>第二个解决方案是使用<span class="inline">@</span> 访问器来直接改变数组的值，这样就省去了制作临时拷贝的CPU开销。这意味着你不需要从函数中返回数组，可以直接编辑它。</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[@ 1] = 200;<br />
    }</p>
  <p>使用这个访问器可以绕过写时复制行为，直接修改引用的数组。这可以用来选择性地禁用特定语句的写时复制，同时保持该选项的启用。</p>
  <p>同样，如果<strong>写时复制</strong>被<strong>禁用</strong>（这是默认和推荐的选项），所有这些就没有必要。</p>
  <p>在下面的页面中可以找到更多关于访问器的信息，以及它们如何工作，还有一个数组的例子。</p>
  <ul class="colour">
    <li><a href="Accessors.htm">访问者</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">返回。<a href="GML_Overview.htm">GML概述</a></div>
        <div style="float:right">下一步。<a data-xref="{title}" href="Structs.htm">结构和构造器</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Arrays
passing arrays to scripts
deleting arrays
-->
  <!-- TAGS
arrays
-->
</body>
</html>
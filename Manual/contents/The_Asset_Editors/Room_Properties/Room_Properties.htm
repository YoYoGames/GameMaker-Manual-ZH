<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>房间属性</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the different room properties" />
  <meta name="rh-index-keywords" content="Rooms - Room Settings" />
  <meta name="search-keywords" content="room settings,cameras,viewports,room size,room properties,view cameras" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>房间属性</h1>
  <p><img> <span class="notranslate">Room</span> 属性部分是你可以设置设置的继承切换，改变持久性、房间的大小和管理视口等选项。</p>
  <h2>持久性</h2>
  <p>通常情况下，当你离开一个<span class="notranslate">room</span> ，以后再回到同一个<span class="notranslate">room</span> ，该<span class="notranslate">room</span> 就会被重置为其初始设置。这对大多数游戏来说通常是好的，但在例如RPG或任何非线性游戏中，这可能不是你想要的，你想在<span class="notranslate">rooms</span> ，并让它们保持你上次离开时的样子。勾选标有 "<strong>持久 </strong>"的方框就可以做到这一点。<span class="notranslate">room</span> 的状态将被记住，当你以后回到它时，它将与你离开时完全一样，只有当游戏重新启动时，它才会被重置为起始状态。请注意，这有<em>一个 </em>例外--如果你把某些<span class="notranslate">objects</span> 标记为持久化，这个<span class="notranslate">object</span> 的实例将<em>不会 </em>留在<span class="notranslate">room</span> ，而是移动到下一个<span class="notranslate">room</span> 。</p>
  <h2 id="clear_display_buffer">清除显示缓冲区</h2>
  <p>之后，你可以选择<strong>清除显示缓冲区</strong>。这个选项被选中后，在为某一帧绘制其他东西之前，会预先用一种颜色填充<a class="glossterm" data-glossterm="显示缓冲区" href="#">显示缓冲区</a>。如果你知道你的视图将一直覆盖整个屏幕，或者你有一个全屏的不透明背景正在绘制，那么你可以不勾选这个选项，这样可以节省重新绘制的时间，因此有助于优化你的游戏。</p>
  <p>然而，如果你有多个视图，在屏幕上留下空隙，或者你的背景有透明部分--你可以检查这一点，这样任何空白区域都会被你选择的绘图颜色填满。目前这个颜色只能通过代码设置，使用 <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/The_Game_Window/window_set_colour.htm"><span class="inline">window_set_colour()</span></a>.</p>
  <p class="note"><span class="note">注意</span>如果你使用自动长宽比校正（在<a href="../../Settings/Game_Options.htm">游戏选项</a>中设置），那么你应该<strong>总是 </strong>勾选这个选项，否则你会在游戏绘制的 &quot;信箱 &quot;中得到奇怪的效果。如果你不使用这个选项，那么你可以不勾选它，从而使你的游戏性能得到小幅提升（在<span class="notranslate">Android</span> 和其他移动平台上尤其明显）。</p>
  <h2>宽度、高度和其他选项</h2>
  <p>一个<span class="notranslate">room</span> ，必须有一个尺寸，这是由你为其宽度和高度输入的像素值定义的。</p>
  <p>然后你可以添加<strong>创建代码</strong>，如果你需要它。创建代码是从底部的按钮中添加的（同时还有<span class="notranslate">inherit</span> 切换，表示<span class="notranslate">room</span> 是否应该<span class="notranslate">inherit</span> 它的创建代码），如果你点击它，你将打开一个代码或视觉编辑器。这个编辑器允许你输入函数/动作和代码，这些函数/动作和代码将在<span class="notranslate">room</span> ，所有实例的创建事件之后但在其<span class="notranslate">room</span> <em>开始 </em>事件之前运行（关于事件顺序的更多信息，请看<a href="../Object_Properties/Event_Order.htm">这里</a>）。这段代码将在你每次进入<span class="notranslate">room</span> 时运行，除非<span class="notranslate">room</span> 被标记为持久性，在这种情况下，它将只在第一次进入<span class="notranslate">room</span> 时运行一次，但在以后访问<span class="notranslate">room</span> 时不运行。</p>
  <h2 id="creation_order">实例创建顺序</h2>
  <p><span class="notranslate">Room</span> 属性中的最后一个按钮允许你打开<strong>实例创建顺序</strong>窗口。</p>
  <p><img>这个窗口按照创建的顺序（从上到下）列出<span class="notranslate">room</span> 中的所有实例。如果你需要在其他实例之前创建一个特定的实例，你可以简单地点击<img> ，然后把它拖到你需要的位置。请注意，实例将按照列表中从上到下的顺序创建。</p>
  <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
  <p> </p>
  <p> </p>
  <h1>摄像机和观景台</h1>
  <p>你可以为<span class="notranslate">room</span> 定义的下一组属性是与房间<strong>相机</strong>和<strong>视口</strong>有关的属性。摄像机视图提供了一种机制，可以在屏幕上的不同地方绘制你的<span class="notranslate">room</span> ，或者只绘制你的<span class="notranslate">room</span> 的一部分来覆盖整个屏幕。例如，在大多数平台游戏中，摄像机视角是跟着主角走的，因为，如果你能在屏幕上看到整个关卡，你的角色就会太小而看不到，对玩家来说就没有惊喜了。摄像机视角也可用于多人游戏或合作游戏，因为它允许你创建一个分屏设置，在屏幕的一部分你看到一个玩家，在另一部分你看到另一个玩家。这一切都可以在<span data-keyref="GameMaker Name">GameMaker</span>中使用摄像机视图轻松实现。</p>
  <p><img>在视图属性的顶部，你可以切换视图的继承性，然后有一个标有<strong>启用视口</strong>的方框。在你的游戏中使用任何相机视图之前，<em>必须标记</em>这个。</p>
  <p class="note"><span class="note">注意</span>你可以为三个主视口的设置打开或关闭继承权，然后你可以为每个单独的相机视图打开或关闭继承权。</p>
  <p>下一个复选框是 "<strong>清除视口背景</strong>"，它类似于上面给出的 "<a href="#clear_display_buffer">清除显示缓冲区</a>"选项，但专门用于视口。启用后，它在绘制每一帧之前用窗口的颜色清除<a class="glossterm" data-glossterm="应用面" href="#">应用程序的表面</a>。这可以确保你不会通过背景中的透明区域看到任何意外的图形，比如之前的帧的内容；所以如果你的背景包含任何透明的东西，启用这个选项（和<strong>&quot;启用视口</strong>&quot;一起）很重要。</p>
  <p>一个摄像机视图是由两组不同的值定义的，摄像机视图本身和屏幕上要绘制这个视图的端口。这有时会引起混淆，所以在解释如何定义它们之前，我们先解释一下。</p>
  <ul class="colour">
    <li><strong>摄像机</strong>。<span class="notranslate">room</span> 内的一个点，它将被用来设置<span class="notranslate">room</span> 在屏幕上的显示方式（这是<span class="notranslate">room</span> 编辑器中的一个抽象点，其位置是根据视图和视口设置自动设置的）。</li>
    <li><strong>视图</strong>。摄像机看到的东西，基于摄像机的位置、投影和旋转。</li>
    <li><strong>视图端口</strong>：物理屏幕上将显示摄像机视图的区域。</li>
  </ul>
  <p><img>因此，例如，这意味着你可以在你的<span class="notranslate">room</span> ，然后将端口设置为320x240，这将在屏幕上显示按比例缩小到该尺寸的端口的视图，你也可以做同样的事情，将视图设置为一个较小的值，而将端口设置为较大的值，使图像比例上升以适应端口的尺寸，在屏幕上显示比它大。通过这种方式，你可以保持屏幕（端口）的大小，同时改变相机视图，在屏幕的同一区域显示更多或更少的<span class="notranslate">room</span> 。</p>
  <p>摄像机视图总是在<span class="notranslate">room</span> 中被定义为一个矩形区域，在这里你指定左上角的位置，这个区域的宽度和高度。然后，你必须通过定义视图端口来指定这个区域在屏幕上的窗口中的显示位置，在这里你也要指定左上角的位置和尺寸（注意，左上角的位置如果不是0,0的话，会产生奇怪的结果）。你可以有一个以上的端口，它们可以重叠，在这种情况下，它们会按照指定的顺序一个一个地画出来。</p>
  <p>请注意，整个屏幕区域<em>总是被定义为一个矩形区域</em>，所以你的端口，即使是偏移，也会形成一个矩形，任何空隙都会被<a class="glossterm" data-glossterm="显示缓冲区" href="#">显示缓冲区</a>的窗口颜色所填满，这意味着在这些情况下，你应该总是选中<strong>Clear Display Buffer</strong>，否则你会在端口之间的空隙中得到奇怪的人工痕迹。下面的图片说明了这一点，有两个偏移的视图端口是可见的，但它们构成了一个正方形的窗口，而 &quot;下面 &quot;有线条被绘制到显示缓冲区。</p>
  <p><img>摄像机也有<strong>物体跟踪 </strong>选项。这是当你想让摄像机 &quot;跟随&quot;（即：保持视图聚焦在）某个<span class="notranslate">object</span> 。要做到这一点，你必须点击菜单图标上的<img> ，并从弹出的列表中选择一个<span class="notranslate">object</span> （如果在<span class="notranslate">object</span> ，有多个此<span class="notranslate">room</span> 的实例，摄像机只跟随其中一个）。</p>
  <p>摄像机的正常行为是，只有当被跟踪的实例过于接近一个 &quot;缓冲 &quot;区时才会移动，这个缓冲区在视图的边缘形成一个无形的边界。这个区域可以由你用<strong>水平边界 </strong>和<strong>垂直边界 </strong>的值来定义，所以--例如--将这些值设置为64意味着视图不会开始移动并跟随角色，直到它到达视图边缘的64像素。</p>
  <p>最后，你可以指示当角色到达<span class="notranslate">buffer</span> 区域时摄像机的<strong>水平</strong>和<strong>垂直 </strong>移动<strong>速度 </strong>，这个默认值为-1。这个默认值基本上是 &quot;瞬时 &quot;的，意味着当跟随实例在水平边界或垂直边界<span class="notranslate">buffer</span> 区域之外的那一刻，视图将跳到其当前位置。现在，这并不总是你想要的，所以你可以通过将值设置为-1以外的值来设置摄像机的垂直和水平滚动速度。请注意，数值为0将导致视图完全不移动，任何其他的正值都是它在任何一帧中移动的像素数，因此将水平速度设置为5将使视图以每帧5像素的水平速度跟随<span class="notranslate">object</span> 。</p>
  <p> </p>
  <p> </p>
  <h1>房间物理学</h1>
  <p>在你可以在游戏中使用内置的物理功能之前，你必须告诉<span data-keyref="GameMaker Name">GameMaker</span>，<span class="notranslate">room</span> 是一个物理<span class="notranslate">room</span> 。要做到这一点，你必须在 "<em>房间物理</em>"部分的顶部勾选 "<strong>启用物理 </strong>"选项（你也可以独立于其他<span class="notranslate">room</span> 设置来切换这部分的继承性）。一旦你这样做了，你就可以继续设置物理学世界属性，这是一些基本的属性，你必须在你的<span class="notranslate">room</span> ，允许物理学实例这样工作之前预先定义好。为了更精确地控制世界，你可以使用代码（更多信息见<a href="../../GameMaker_Language/GML_Reference/Physics/Physics.htm">物理学函数</a>）。</p>
  <p><img>你必须做的下一件事是设置世界的<strong>重力 </strong>。它的强度和方向是以你围绕（0，0）点设置的X/Y位置的<a class="glossterm" data-glossterm="向量" href="#">矢量</a>来计算的。因此，x为0，y为1，重力方向将被设定为<em>向下 </em>，力为每秒1米（更详细的解释见<a href="../../GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm">物理世界</a>）。</p>
  <p>最后你必须设置<strong> Pixels To Meters</strong>的比例，以便<span data-keyref="GameMaker Name">GameMaker</span>将其作为所有物理计算的基础。这是因为物理功能是在真实世界的测量值上工作的，这就是为什么我们必须设置这个值，你要调整这个设置，直到你所使用的<span class="notranslate">objects</span> 的平均像素大小大致转化为适当大小的模拟物理<span class="notranslate">objects</span> 。</p>
  <p>应该注意的是，在<span class="notranslate">room</span> ，启用物理学意味着房间里的所有实例<em>必须使用物理学函数和变量来移动</em>。基本上，你有 &quot;传统 &quot;的运动，你可以设置一个实例的X/Y位置或设置它的速度和方向，然后你有 &quot;物理 &quot;运动，它需要物理力和脉冲来移动。这些系统是<strong>相互排斥的</strong>，你不能使用非物理功能来移动一个物理实例，也不能使用物理功能来移动一个非物理实例。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">返回。<a href="../Rooms.htm"> <span class="notranslate">Room</span> 编辑</a></div>
        <div style="float:right">下一个。<a href="Room_Inheritance.htm">房间的继承权</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Room Properties
View Ports
View Cameras
-->
  <!-- TAGS
rooms_properties
-->
</body>
</html>
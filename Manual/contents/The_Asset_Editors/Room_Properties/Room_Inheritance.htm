<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>房间继承权</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the inheritance functionality of rooms" />
  <meta name="rh-index-keywords" content="Rooms - Inheritance" />
  <meta name="search-keywords" content="room inheritance,inherit,inheritance" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>房间继承权</h1>
  <p> <span class="notranslate">room</span> 编辑器的一个重要特点是<strong>继承性</strong>。继承意味着你可以创建一个 &quot;父房 &quot;<span class="notranslate">room</span> ，然后从它创建一个 &quot;子房 &quot;<span class="notranslate">room</span> ，它将<span class="notranslate">inherit</span> 父房的所有属性。这个子房<span class="notranslate">room</span> ，本质上是父房的<em>克隆 </em>，其中的一切都<strong>与父房相联系</strong>。这意味着，如果你改变了父房的视图，或移动了<span class="notranslate">tile</span> ，或增加了实例，它将反映在子房<span class="notranslate">room</span> 。不仅如此，在子房<span class="notranslate">room</span> ，你可以有选择地<span class="notranslate">switch</span> ，关闭对特定层、实例、<span class="notranslate">assets</span> 或其他任何需要的继承权。</p>
  <p>一个有继承属性的<span class="notranslate">room</span> ，会有<span class="notranslate">inherit</span> 按钮被点亮--如下图所示--然后你可以用它们来切换给定图层或资源的继承权的开或关。</p>
  <p><img>这在一开始可能有点难以想象，所以让我们看一个例子：假设你有一个<span class="notranslate">room</span> ，中间有一个城市和一个城堡。城市和城堡是用不同的<span class="notranslate">tile</span> 图层绘制的，你也有实例和一些<span class="notranslate">paths</span> ，供NPC使用，以便走动。你想让它在游戏中的城堡被摧毁，但城市中的其他东西看起来和行为都是一样的。你将创建一个初始的<span class="notranslate">room</span> ，一切正常，然后你将创建一个子<span class="notranslate">room</span> ，该<span class="notranslate">inherits</span> ，父<span class="notranslate">room</span> 层。<span class="notranslate">room</span> 在子<span class="notranslate">switch</span> ，你可以<em>关闭 </em>城堡区域的<span class="notranslate">tile</span> 层的继承权（甚至是单独的<span class="notranslate">tiles</span> ），然后移动/添加/删除<span class="notranslate">tiles</span> ，以创建被摧毁的城堡外观。当玩家进入该<span class="notranslate">room</span> ，所有来自父<span class="notranslate">room</span> 和所有<span class="notranslate">tiles</span> 等的实例将保持完全相同，除了那些被摧毁的城堡。</p>
  <p class="note"><strong>重要的是!</strong>如果你编辑任何继承的属性，它将自动关闭它所属部分的继承，而不必首先切换<span class="notranslate">inherit</span> 按钮。</p>
  <p>要创建<span class="notranslate">room</span> 继承，你只需在<a href="../../Introduction/The_Asset_Browser.htm">资产浏览器</a>中选择你想创建子房的<span class="notranslate">room</span> ，然后右键单击<img> 。这将打开<span class="notranslate">room</span> 菜单，在那里你可以选择<strong>创建子房 </strong>来创建一个新的子<span class="notranslate">room</span> 。这将在<span class="notranslate">Asset</span> 浏览器中创建。</p>
  <p><img>要改变<span class="notranslate">room</span> 的顺序和/或继承，你需要使用<a href="../../Settings/The_Room_Manager.htm">房间管理器</a>，你可以使用<span class="notranslate">Asset</span> 浏览器右上方的菜单打开它。在这里，你可以进入<em>继承 </em>选项卡，然后点击<img> ，将任何<span class="notranslate">room</span> 拖到任何其他<span class="notranslate">room</span> ，使其成为该<span class="notranslate">room</span> 的子女（或将子女<span class="notranslate">room</span> 从父方拖走，打破继承关系）。</p>
  <p><img> <span class="notranslate">room</span> 注意，在一个 ，继承是多层次的，你可以检查单个项目、单层上的项目组、项目属性或整个 作为继承，你也可以从连续的 （所以 C 从 B，而后者又从 A继承）。例如，如果你创建了一个除了视图设置之外什么都没有的基础 ，那么你可以创建所有进一步的 ，作为它的子代，它们都将 父 的视图属性。但你可以更进一步，创建另一个以 &quot;视图 &quot; 为父本的基础 ，它拥有一般<span class="notranslate">rooms</span> <span class="notranslate">inherit</span> <span class="notranslate">rooms</span> <span class="notranslate">room</span> <span class="notranslate">inherits</span> <span class="notranslate">room</span> <span class="notranslate">Room</span> <span class="notranslate">room</span> <span class="notranslate">rooms</span> <span class="notranslate">inherit</span> <span class="notranslate">room</span> <span class="notranslate">room</span> <span class="notranslate">room</span> <a class="glossterm" data-glossterm="GUI" href="#">GUI</a>实例和每个游戏所需的控制器 。现在你可以从中创建子 ，它们将 ，同时拥有来自父 的控制器和GUI，以及来自该 父的视图设置!<span class="notranslate">room</span> <span class="notranslate">rooms</span> <span class="notranslate">inherit</span> <span class="notranslate">room</span> <span class="notranslate">room</span></p>
  <p>正如你希望看到的，继承是非常强大的，你可以用它来维护一个更干净的<span class="notranslate">room</span> 结构，加快工作流程，并普遍优化你在制作和设计<span class="notranslate">rooms</span> 。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">返回。<a href="../Rooms.htm"> <span class="notranslate">Room</span> 编辑</a></div>
        <div style="float:right">下一步。<a href="Filters_and_Effects.htm">滤波器和效果</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2021 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Room Inheritance
-->
  <!-- TAGS
rooms_inheritance
-->
</body>
</html>
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>物品</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing how the object editor works" />
  <meta name="rh-index-keywords" content="Object Editor" />
  <meta name="search-keywords" content="objects,object editor" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>The<span class="notranslate">Object</span> 编辑</h1>
  <p><img>对象是我们用来控制游戏的各个方面和做具体事情的资源。大多数时候，它们有一个与之相关的<span class="notranslate">sprite</span> ，以便你在游戏中看到它们<span class="notranslate">rooms</span> ，但有时它们被用作 &quot;幕后 &quot;控制器，做与用户有关的事情或用于计时，等等。它们可以被赋予行为，它们可以对某些事件以及相互之间作出反应，你在游戏中看到的大多数东西都是基于<span class="notranslate">objects</span> 和它们的互动。<span class="notranslate">objects</span>现在，我们说 &quot;基于 &quot;是因为你实际上并没有直接将<span class="notranslate">rooms</span> ，而是将这些<span class="notranslate">objects</span> ，这些<strong>实例</strong>基本上是<span class="notranslate">object</span> 资源的副本（或克隆，如果你愿意）。这是一个非常重要的事情，要记住，因为实例和<span class="notranslate">objects</span> <em>是不一样</em>的，各自都有自己的一套功能可以影响它们。</p>
  <p>为了澄清这一点，想想用<span data-keyref="GameMaker Name">GameMaker</span>制作的游戏。所有的角色、怪物、球、墙等等......都是你在<a href="../Introduction/The_Asset_Browser.htm">资产浏览器</a>中创建的<span class="notranslate">objects</span> 。然后你把<em>对象 </em>拖到<a href="Rooms.htm">房间编辑器</a>中的<span class="notranslate">room</span> ，创建一个从基本的<span class="notranslate">object</span> 模板复制的<em>实例 </em>。然后，<span class="notranslate">room</span> 中的实例可以在编辑器本身或通过代码进行更改，这样它就可以被缩放，或着色，或从 &quot;基本 &quot;<span class="notranslate">object</span> 中修改其他细节。因此，当我们谈论影响或改变一个<strong>实例</strong>的东西时，我们的意思是它会影响<em>房间里的</em>那个<em>特定的<span class="notranslate">object</span> </em> 。只有那个单一的实例受到影响，而其他所有的都没有受到影响。但是，当我们谈论影响或改变一个<strong>对象</strong>时，我们的意思是，我们正在修改<span class="notranslate">object</span> 浏览器中的<span class="notranslate">Asset</span> ，我们对它所做的任何事情也将反映在从这一点开始创建的所有实例上。所以，<span class="notranslate">object</span> 是实例的模板，而实例是我们放置在<span class="notranslate">room</span> 来制作游戏的东西。</p>
  <p>要在你的游戏中创建一个<span class="notranslate">object</span> ，你可以在<span class="notranslate">Asset</span> 浏览器上右击<img> ，然后点击<em>创建对象</em>选项。这将打开本页面顶部的窗口，其中有以下部分。</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">详情</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">在这里你可以给你的<span class="notranslate">object</span> 一个名字。这个名字不应包含空格或未经授权的字符（只允许使用字母数字字符和下划线&quot;_&quot;），而且应该简短但易于记忆，以便你在以后可能有很多资源的情况下，可以轻松地识别资源
      当你可能有许多资源时，你可以很容易地识别它们。例如，许多人使用前缀或后缀来识别资源之间的差异，如 &quot;<span class="inline">obj_Ship</span>&quot; 或 &quot;<span class="inline">Ship_obj</span>&quot; 。</p>
    <p class="dropspot">接下来你可以选择<span class="notranslate">sprite</span> ，如果你希望它有一个<span class="notranslate">object</span> 。用鼠标左键点击<img> ，<span class="notranslate">sprite</span> ，<strong>资产资源管理器</strong>将出现一个列表，其中包括<span class="notranslate">sprites</span> 浏览器中所有可用的<span class="notranslate">Asset</span> 。</p>
    <p class="dropspot"><img> <span class="notranslate">object</span> 然后你可以选择你想用于<span class="notranslate">sprite</span> 。在为<span class="notranslate">object</span> ，你可以点击<em>编辑精灵</em>按钮<img> ，以改变<a href="Sprites.htm">精灵的属性</a>，或者--如果你没有<span class="notranslate">sprite</span> ，但希望创建一个--你可以点击添加精灵按钮 ，创建一个新的<span class="notranslate">object</span> ，并将其分配。
     <em>添加精灵</em>按钮<img> ，创建一个新的<span class="notranslate">sprite</span> <span class="notranslate">asset</span> ，并将其分配。你也可以通过点击 "编辑图像 "按钮来编辑已经分配的<span class="notranslate">sprite</span> <span class="notranslate">asset</span> 图像。
      点击<em>编辑图像</em>按钮<img> ，打开<a href="Image_Editor.htm">图像编辑器</a>。</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">碰撞面具</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">在<span class="notranslate">sprite</span> 赋值区下面有一个按钮，用于选择一个特定的<strong>碰撞掩码</strong>。默认情况下，一个<span class="notranslate">object</span> 将根据分配给它的<span class="notranslate">sprite</span> 产生碰撞属性，但在某些情况下，你可能希望碰撞是基于不同的 的不同形状。
      碰撞是基于不同的形状，来自不同的<span class="notranslate">sprite</span> 。例如，你可能有一个自上而下的游戏，主<span class="notranslate">sprite</span> 有一个长方形的碰撞掩码，但为了使碰撞更平滑，一个圆形的掩码可能更好。在这种情况下
      你可以点击碰撞遮罩按钮并选择另一个<span class="notranslate">sprite</span> 资源，所以现在<span class="notranslate">object</span> 的实例将<em>绘制 </em>指定的<span class="notranslate">sprite</span> ，但基于遮罩的<em>碰撞 </em> <span class="notranslate">sprite</span> 。你可以从Sprim的页面上找到更多关于碰撞遮罩的信息。
      你可以在<a href="Sprites.htm">Sprite Editor</a>的页面上找到更多关于碰撞遮罩的信息。</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">财产</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">这里你会看到你的对象有以下选项。<strong></strong></p>
    <ul class="dropspotlist">
      <li class="dropspot"><strong>可见的</strong>。Visible表示当<span class="notranslate">object</span> 开始时，这个<span class="notranslate">room</span> 的实例是否可见。通常情况下，大多数实例都是可见的，但有时拥有不可见的实例是很有用的--例如，你可以用它们作为控制移动怪物的路标，或者保持跟踪值并执行某些定时动作。不可见的<span class="notranslate">objects</span> ，仍然会对事件做出反应，如果它们有一个<span class="notranslate">sprite</span> ，或者为它们分配了一个掩码，那么如果其他实例与它们相撞，它们也会做出反应......它们只是不能被看到，也<em>不会 </em>执行它们的<strong>绘制事件</strong>。默认情况下，可见的<span class="notranslate">flag</span> 被选中。<strong></strong></li>
      <li class="dropspot"><strong>固体</strong>：当你<span class="notranslate">flag</span> 一个实例为固体时，你是在告诉<span data-keyref="GameMaker Name">GameMaker</span>，它应该在触发<strong>碰撞事件</strong>之前尝试解决任何碰撞。这是一个非常基本的功能，实际上它所做的只是在执行碰撞事件本身中的任何代码或<span class="notranslate">GML</span> Visual之前，将实例移回到检测到碰撞之前的位置，因此用途有限。</li>
      <li class="dropspot"><strong>持久性</strong>。持久性<span class="notranslate">object</span> 是指当<span class="notranslate">room</span> 被改变时，它不会消失，而是 &quot;持续存在 &quot;并被带入新的<span class="notranslate">room</span> 。只有当你明确地销毁它时，它才会消失，无论是用销毁动作还是在代码中。<span class="notranslate">object</span> 这意味着，如果你在一个<span class="notranslate">room</span> ，它仍然可以在所有后续的<span class="notranslate">rooms</span> ，并将继续执行分配给其<span class="notranslate">object</span> 属性中的事件的任何动作，<em>除了 </em> <strong>创建事件</strong>，它只在最初创建时被触发<em>一次 </em>，而不是在你改变到一个新的<span class="notranslate">room</span> 。当你有，例如，一个主角从<span class="notranslate">room</span> 移动到<span class="notranslate">room</span> ，并且你想保持实例内的变量不变时，这很方便，但你应该非常小心地正确创建和销毁持久化的<span class="notranslate">objects</span> ，因为你很容易误入你的项目而产生错误。</li>
    </ul>
    <p class="dropspot"><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#" style="margin-left:88px">持久性和<span class="notranslate">Room</span> 层</a>  </p>
    <div class="droptext" data-targetname="drop-down7">
      <p class="dropspot" style="margin-left: 132px">当你在<span class="notranslate">room</span> 中创建一个启用了持久性的实例时，它将被分配一个层或一个深度（取决于你用哪个函数来创建<span class="notranslate">object</span> 的实例）。当改变<span class="notranslate">room</span> ，如果下面的<span class="notranslate">room</span> ，没有一个与所分配的层相同的名称或深度，那么<strong> 将为跨房间持久化的实例创建一个新的层</strong>。如果你在创建实例时给了一个命名的图层，那么新的图层也将被命名为与原来的图层相同，而如果你给实例分配了一个深度，那么新的图层将被命名为 &quot;<span class="inline">_layer_XXX</span>&quot;，其中 &quot;<span class="inline">XXX</span>&quot;是一个十六进制值，用于给图层一个唯一的名字。这些图层将在<strong>房间结束</strong>时从<span class="notranslate">room</span> 中删除。<br>
        <br>
        关于图层和持久化实例需要注意的另一件事是，如果你在创建时给实例分配了一个命名的图层，而在下面的<span class="notranslate">rooms</span> ，有另一个具有相同名称的图层，那么持久化的实例将被分配到具有相同名称的图层，而不管图层的深度如何。<br>
        <br>
        最后，如果一个持久化的实例移动到一个<span class="notranslate">room</span> ，该层的深度与实例创建时的深度<em>相同</em>，那么它将<em>不会 </em>被分配到这个层，而是在相同的深度创建一个新的层（按照上面解释的命名规则）。
      </p>
    </div>
    <p class="dropspot"><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#" style="margin-left: 88px">持久性和事件</a></p>
    <div class="droptext" data-targetname="drop-down6">
      <p class="dropspot" style="margin-left: 132px">如前所述，一个持久的<span class="notranslate">object</span> ，只会运行<em>一次</em>它的<strong>创建事件</strong>，但它也会在适当的时候触发<strong>游戏开始</strong>、<strong>游戏结束</strong>、<strong>房间开始</strong>和<strong>房间结束</strong>事件。然而，如果你重新启动游戏（例如用 <span class="inline">game_restart()</span> 功能），<em>所有持久的<span class="notranslate">objects</span> 将被删除，只有在游戏再次创建时才存在</em>。<br>
        <br>
        还要注意的是，如果你<strong>停用了一个 </strong>持久性的<span class="notranslate">object</span> ，它将不再从一个<span class="notranslate">room</span> 传递到另一个，除非在<strong>房间结束</strong>事件被触发之前重新激活。重新激活<em>需要一个完整的游戏步骤</em>，所以使用实际的<strong>房间结束</strong>事件是行不通的，因为它没有给游戏一个完整的步骤来重新激活<span class="notranslate">object</span> ，所以在使用停用和持久化<span class="notranslate">objects</span> ，你需要记住这一点，并相应地计划你的代码。
      </p>
    </div>
    <ul class="dropspotlist">
      <li class="dropspot"><strong>使用物理学</strong>。当你勾选了Uses Physics（使用物理学）框，你就告诉<span data-keyref="GameMaker Name">GameMaker</span>这个<span class="notranslate">object</span> 应该是物理学世界的一部分（如在<strong></strong><a href="Rooms.htm"></a> Room Editor中设置的那样。勾选这个选项还将打开一个进一步的链式窗口，在这里你可以定义这个<span class="notranslate">object</span> 的所有实例的物理属性。关于这一点的更多信息可以在<a href="Object_Properties/Physics_Objects.htm">物理对象</a>一节中找到。</li>
      <li class="dropspot"><strong>管理</strong>。使用<a href="../GameMaker_Language/GML_Reference/Rollback/Rollback_Multiplayer.htm">回滚多人游戏</a>时，这个<span class="notranslate">object</span> 是否应该被管理<a href="../GameMaker_Language/GML_Reference/Rollback/Rollback_Multiplayer.htm">。</a>被管理对象的状态可以<i>回滚</i>，可以对其运行预测。参见<a data-xref="{text}" href="../GameMaker_Language/GML_Reference/Rollback/Rollback_System.htm#h2">被管理对象</a>。</li>
    </ul>
  </div>
  <p> </p>
  <p><span class="notranslate">Object</span> 编辑器的最后一部分是不同的对象<strong>选项</strong>，每个选项都在其页面上讨论，链接如下。</p>
  <ul class="colour">
    <li><a href="Object_Properties/Object_Events.htm">对象事件</a></li>
    <li><a href="Object_Properties/Parent_Objects.htm">父对象</a></li>
    <li><a href="Object_Properties/Physics_Objects.htm">物理学对象</a></li>
    <li><a href="Object_Properties/Object_Variables.htm">对象变量</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">返回。<a href="The_Asset_Editors.htm">资产编辑部</a></div>
        <div style="float:right">下一步。<a href="Paths.htm">路径</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Object Editor
Objects
-->
  <!-- TAGS
object_editor
-->
</body>
</html>